---
title: SpringMVC控制器中的注解介绍
date: 2021-08-22 21:47:29
permalink: /pages/70416e/
categories:
  - 《SpringMVC》学习笔记
tags:
  - 
---
# SpringMVC控制器中的注解介绍

# 1、`@RequestMapping`:1st_place_medal:

`@RequestMapping(method = RequestMethod.GET)`，这行代码即说明`@GetMapping`就是`@RequestMapping`附加了请求方法。同时，可以看到`@GetMapping`这个注解 是`spring4.3`版本引入，同时引入的还有`@PostMapping`、`@PutMapping`、`@DeleteMapping`和`@PatchMapping`，一共5个注解。

所以，一般情况下用`@RequestMapping(method = RequestMethod. XXXX)`即可。

### @RequestMapping("/article")

【示例】单个地址，**可以在类上使用，也可以在方法上使用**

```java
@Target({ElementType.TYPE, ElementType.METHOD})
```

```java
@Controller
@RequestMapping("/article")
public class ArticleController {

    @Autowired
    private ArticleService articleService;

    @GetMapping("/getarticle")
    public ResponseData<ArticleAndTypeDto> getAllArticle(){
        ...
    }
}
```

此时@RequestMapping("/article")表示的是该控制器通用前缀名为 上下文/article.即，当我们访问getAllArticle方法的时候，不能直接使用http://localhost:8080/getarticle，而是要使用：http://localhost:8080/article/getarticle

### @RequestMapping{"/article","/art"}

【示例】可以采用这种形成编写多个地址，**可以在类上使用，也可以在方法上使用**

```java
@Target({ElementType.TYPE, ElementType.METHOD})
```

```java
@Controller
@RequestMapping{"/article","/art"}
public class ArticleController {

    @Autowired
    private ArticleService articleService;

    @GetMapping("/getarticle")
    public ResponseData<ArticleAndTypeDto> getAllArticle(){
        ...
    }
}
```

此时`RequestMapping{"/article","/art"}`表示的是该控制器通用前缀名为多个上下文`/article`，`/art`，即当我们访问`getAllArticle`方法的时候：

可以使用：http://localhost:8080/article/getarticle

也可以使用：http://localhost:8080/art/getarticle



### @RequestMapping六个属性

* `value`： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；
* `method`： 指定请求的method类型， GET、POST、PUT、DELETE等；
* `consumes`： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;
* `produces`:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；
* `params`： 指定request中必须包含某些参数值是，才让该方法处理。
* `headers`： 指定request中必须包含某些指定的header值，才能让该方法处理请求。





# 2、`@Controller`:zap:

在默认不做其他处理的情况下，没有返回`ajax`请求，就是普通的转发跳转，则使用`@Controller`注解。

测试返回这个字符串并不是数据内容，而是一个视图！

```java
@Controller
public class BlogController {
    @GetMapping("blog")
    public String getBlgo() {
        return "blog: id = 1 ,title = 测试";
        //return "blogList";
    }
}
```





# 3、`@ResponseBody `:point_up_2:

* 作用： 在控制器层使用 **@ResponseBody**返回数据 ，可以设置返回格式 application/json;
* 如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。
* 如果方法加上了@ResponseBody注解，Spring返回值到响应体。如果这样做的话，Spring将根据请求中的 Content-Type header（私下）使用 HTTP Message converters 来将domain对象转换为响应体。

```java
@Controller  
@RequestMapping(value = "/user/{userId}", method = RequestMethod.GET, produces="application/json")  
@ResponseBody  
public User getUser(@PathVariable String UserId, Model model) {      
    // implementation omitted  
} 
```





# 4、`@RequestBody `:point_up_2:

* 使用@RequestBody是将json格式的数据传递给方法;请求参数对象;
* 将视图资源传递给控制器, @RequestBody控制器只接收json格式的数据

```java
@PostMapping("/addarticle")
public AjaxOperateResponse addArticle(@RequestBody ArticleEntity article) {
    AjaxOperateResponse response = new AjaxOperateResponse(200, articleService.addArticle(article) ? "增加成功" : "增加失败");
    return response;
}
```





# 5、`@RestController`:pizza:

* 如果希望这个控制器中所有的方法返回值都是`ajax = > json`，则使用`@RestController`注解
* **`@RestController`**注解相当于`@ResponseBody `＋`@Controller`合在一起的作用。
* 如果只是使用`@RestController`注解`Controller`，则`Controller`中的方法无法返回`jsp`页面，配置的视图解析器`InternalResourceViewResolver`不起作用，返回的内容就是`return `里的内容。
* 如果需要返回`JSON`，XML或自定义`mediaType`内容到页面，则需要在对应的方法上加上`@ResponseBody`注解。

```java
@RestController
public class ArticleController {

    @Autowired
    private ArticleService articleService;

    @DeleteMapping("/delarticle/{articleID}")
    public ResponseData deleteArticleByID(@PathVariable("articleID") int articleID) {
        ResponseData responseData = articleService.deleteArticleByID(articleID);
        return responseData;
    }
}
```





# 6、`@GetMapping` :imp:

`@GetMapping`用于将`HTTP` ` get`请求映射到特定处理程序的方法注解
具体来说，`@GetMapping`是一个组合注解，是`@RequestMapping(method = RequestMethod.GET)`的缩写。该注解将`HTTP` `Get `映射到 特定的处理方法上。

```java
@GetMapping("/getarticle")
public ResponseData<ArticleAndTypeDto> getAllArticle(
    @RequestParam(name = "page", required = true, defaultValue = "1") int page,
    @RequestParam(name = "limit", required = true, defaultValue = "10") int limit,
    @RequestParam(name = "keywords", required = true, defaultValue = "") String keywords) {
    ResponseData<ArticleAndTypeDto> articleList = articleService.getArticleList(page, limit, keywords);
    return articleList;
}
```





# 7、`@PostMapping`:imp:

`@PostMapping`用于将`HTTP` `post`请求映射到特定处理程序的方法注解
具体来说，`@PostMapping`是一个组合注解，是`@RequestMapping(method = RequestMethod.POST)`的缩写。

```java
@PostMapping("/addarticle")
public AjaxOperateResponse addArticle(@RequestBody ArticleEntity article) {
    AjaxOperateResponse response = new AjaxOperateResponse(200, articleService.addArticle(article) ? "增加成功" : "增加失败");
    return response;
}
```





# 8、`@RequestParam`:tada:

* @**RequestParam**用于将请求参数区数据映射到功能处理方法的参数上
* @**RequestParam**只能在参数位置使用

```java
@Target(ElementType.PARAMETER)
```

```java
@GetMapping("/getarticle")
public ResponseData<ArticleAndTypeDto> getAllArticle(
    @RequestParam(name = "page", required = true, defaultValue = "1") int page,
    @RequestParam(name = "limit", required = true, defaultValue = "10") int limit,
    @RequestParam(name = "keywords", required = true, defaultValue = "") String keywords) {
    ResponseData<ArticleAndTypeDto> articleList = articleService.getArticleList(page, limit, keywords);
    return articleList;
}
```

* 通过`@RequestParam("name = "?")`明确告诉Spring Web MVC使用name进行入参。value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；

* `required`：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报400错误码；如果设置了`required=true`,同时提供`defaultValue`的话，此时不传递参数，方法也能正常执行，默认值就是参数的值.

* `defaultValue`：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是`SpEL`表达式.此时 如果没有传递参数过来 ，方法不能正常正常执行，必须要传递参数name才可以





# 9、`@PathVariable`:tada:

* RestFul通用风格
* @**PathVariable**用于将请求URL中的模板变量映射到功能处理方法的参数上。
* @**PathVariable**该注释只能在参数位置使用

```java
@Target(ElementType.PARAMETER) 元素类型.参数
```

### 【示例1】传递参数

```java
@RequestMapping(value="/add3/{userId}/{userName}/a")
public String requestParam3(@PathVariable(value="userId") int userId,@PathVariable("userName") String userName)
{
    System.out.println("userId :"+userId+" ,userName :"+userName);
    return "add";
}
```

说明：当浏览器地址栏输入: http://localhost:8080/SpringMvcDemo03/hc5/add3/888/laowang/a

可以访问到该方法:同时控制台可以得到：

`userId` :888 

`userName` :laowang

即通过访问该方法同时传递参数`userId` :888 ;`userName` :laowang



### 【示例2】传递参数

```java
@PutMapping("/updatest/{articleStatus}/{articleID}")
public ResponseData updateArticleStatus(
    @PathVariable("articleStatus") int articleStatus,
    @PathVariable("articleID") int articleID) {
    ResponseData responseData = articleService.updateArticleStatus(articleID, articleStatus);
    return responseData;
}
```

说明：当浏览器地址栏输入: http://localhost:8080/updatest/1/0

可以访问到该方法:同时控制台可以得到：

`articleStatus:`0

`articleID:`1

即通过访问该方法同时传递参数`articleStatus:0`,` articleID:1`可修改文章ID为1的文章状态为0



### 【示例3】传递参数

```java
@DeleteMapping("/delarticle/{articleID}")
public ResponseData deleteArticleByID(@PathVariable("articleID") int articleID) {
    ResponseData responseData = articleService.deleteArticleByID(articleID);
    return responseData;
}
```

说明：当浏览器地址栏输入: http://localhost:8080/delarticle/1

可以访问到该方法:同时控制台可以得到：

`articleID:`1

即通过访问该方法同时传递参数`articleID:`1，并删除ID为1的这篇文章





# 10、`@CookieValue`:x:

@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上.

### **【示例1】**

**将本地存储的cookie的Value读取到控制器的方法中来.**

当我们访问网站某个页面成功之后,会有一个sessionId:然后再次请求下面的地址会有一个jsessionId:

```java
@GetMapping("c1")
public String cookietest(@CookieValue(name = "jsessionId") String jsessionId) {
    System.out.println("jsessionId");
    return "test";
}
```

```java
@GetMapping("c2")
public String cookietest(@CookieValue(name = "jsessionId") Cookie jsessionId) {
    System.out.println("jsessionId");
    return "test";
}
```

说明：参数类型可以是string也可以是一个cookie对象



### **【示例2】**

**添加Cookie**，并将本地存储的cookie读取到控制器的方法中来.

```java

@GetMapping("/c3")
public String addCookie(HttpServletResponse response) {
    Cookie cookie = new Cookie("c","singerw");
    response.addCookie(cookie);
    return "test";
}
```



```java
@GetMapping("c4")
public String cookietest2(@CookieValue(name = "c") String c) {
    System.out.println("jsessionId");
    return "test";
}
```





# 11、`@RequestHeader`:candy:

`@RequestHeader`用于将请求的头信息区数据映射到功能处理方法的参数上

```java
@RequestMapping("/requestHeader")
public String requestHeader(
    @RequestHeader(name = "Accept") String accept,
    @RequestHeader(name = "Cookie") String cookie,
    @RequestHeader(name = "Host") String host) {
    System.out.println(accept);
    System.out.println(cookie);
    System.out.println(host);
    return "requestHeader";
}
```

输出结果：

> accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
>
> cookie:Idea-b90d7303=353c5347-21f4-4305-8ba9-e1e67fa3f21e; JSESSIONID=08520270A158EE46B2DA7A5A785D9B18
>
> host:localhost:8080





# 12、`@ModelAttribute`

* @ModelAttribute绑定请求参数到命令对象
* 可以用在方法上，也可以用在方法的参数上面。

```java
@Target({ElementType.PARAMETER, ElementType.METHOD})
```

* **@ModelAttribute具有如下三个作用：**
  * 定请求参数到命令对象：放在功能处理方法的入参(某个控制器的方法参数)上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用；此时,和(Model model) 写法的功能相同
  * 暴露表单引用对象为模型数据：放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping注解的方法）之前，自动添加到模型对象中，用于视图页面展示时使用；
  * 暴露@RequestMapping方法返回值为模型数据：放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用。



### 【示例1】

当我们访问任何带`@ReqyestMapping`的方法的时候，之前都会执行这个`getArticle`这个方法，并返回一个`article`对象.。

```java
@ModelAttribute(value = "/article")
public ArticleEntity getArticle() {
    ArticleEntity article = new ArticleEntity("测试标题", "测试内容", 2);
    return article;
}
```

这个加了`@ModelAttribute(value = "/article")`之后，会将对象的信息存储在request属性的范围内起来，当有`@RequestMapping（@GetMapping，@PostMapping...）`就会先执行这个方法。

所有存储起来的信息就可以使用了

```java
${article}
${requestScope.article}
```



### 【示例2】

一般来说，`return`一个`view`或者`return`一个`ModeAndView`，但是下面方法`return`了一个 `Arrays.asList(article1,article2)`，也是可以跳转到对应视图上，如下方法默认的跳转视图是和请求的`@RequestMapping(value = "/article")`一样的，会转发到`article.jsp`的页面上去,但是也是遵循视图解析器中的配置的。

```java
@RequestMapping(value = "/article")
@ModelAttribute(value = "/articlelist")
public List<ArticleEntity> getArticleList() {
    ArticleEntity article1 = new ArticleEntity("测试标题1", "测试内容1", 1);
    ArticleEntity article2 = new ArticleEntity("测试标题2", "测试内容2", 2);
    return Arrays.asList(article1,article2);
}
```

```xml
<!--视图解析器配置-->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/blog/"/>
    <property name="suffix" value=".jsp"/>
</bean>
```





# 13、`@SessionAttributes`

* @**SessionAttributes**绑定命令对象到session

* @SessionAttributes在类上使用

```java
@Target({ElementType.TYPE})
```

​		有时候我们需要在多次请求之间保持数据，一般情况需要我们明确的调用HttpSession的API来存取会话数据，如多步骤提交的表单。Spring Web MVC提供了@SessionAttributes进行请求间透明的存取会话数据。

### 【示例1】Session原始添加方法：

```java
@GetMapping("/session")
public String sessionArticle(HttpServletRequest request, HttpSession session, SessionStatus status) {
    // 如果session还在，让旧的session过期
    if (!status.isComplete()) {
        status.setComplete();
    }
    ArticleEntity article = new ArticleEntity("测试", "测试", 2);
    // 1通过request添加属性
    request.getSession().setAttribute("session1", article);
    // 2直接通过session对象添加
    session.setAttribute("session2", article);
    return "test";
}
```

在hello_session.jsp就可以直接访问: 

```jsp
${sessionScope.session1}
${sessionScope.session2}
```



### 【示例2】Session添加方法2：

` @ModelAttribute(value = "/articlelist")`与`@SessionAttributes(value = "articlelist")`结合使用。将`@ModelAttribute(value = "/articlelist")`的`value = "/articlelist"`，写到`@SessionAttributes(value = "articlelist")`中，访问页面的时候，会将数据存储到session范围内中。

```java
@Controller
@SessionAttributes(value = "articlelist")
public class TesModelAndSessionController {


    @RequestMapping(value = "/article")
    @ModelAttribute(value = "/articlelist")
    public List<ArticleEntity> getArticleList() {
        ArticleEntity article1 = new ArticleEntity("测试标题", "测试内容", 2);
        ArticleEntity article2 = new ArticleEntity("测试标题", "测试内容", 2);
        return Arrays.asList(article1,article2);
    }
}
```

此时，我的请求范围，和session范围都能获取到`articlelist`中的数据

```jsp
${sessionScope.articlelist}
```



**@SessionAttributes基本原理:**

* 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中;
* 执行@ModelAttribute注解的方法：
  * 如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法进行准备表单引用数据，而是使用①步骤中的会话数据；
  * 如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中.





# 14、`@SessionAttribute`

如果session中绑定多个数据对象:此时使用方法参数

```java
@Controller
@SessionAttributes(value={"list","article"})
public class SessionAttrbuteController {
    
    @RequestMapping("forward105")
    public ArrayList<ArticleEntity> forward105(@ModelAttribute(value = "list") ArrayList list) {
        ArticleEntity article1 = new ArticleEntity("测试标题", "测试内容", 2);
        ArticleEntity article2 = new ArticleEntity("测试标题", "测试内容", 2);
        list.add(article1);
        list.add(article2);
        return list;
        //这里没有设置视图的信息 将会跳转到哪里: /WEB-INF/jsp/forward105.jsp
    }

    @ModelAttribute("list")
    public ArrayList initArrayList() {
        return new ArrayList();
    }

    @RequestMapping("forward106")
    public ArticleEntity forward106(@ModelAttribute(value = "article") ArticleEntity article) {

        article.setArticle_id(1);
        article.setArticle_title("一点都不好玩~");
        return article;
        //这里没有设置视图的信息 将会跳转到哪里: /WEB-INF/jsp/forward106.jsp
    }

    @ModelAttribute("article")
    public ArticleEntity initArticle() {
        return new ArticleEntity();
    }
}
```

