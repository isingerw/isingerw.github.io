---
title: jsp 动态网页开发技术
date: 2021-08-22 21:46:12
permalink: /pages/d8363e/
categories:
  - 《JavaWeb》学习笔记
tags:
  - 
---
# JSP

## 一、Jsp简介

`JSP`全称`Java Server Pages`，是一种动态网页开发技术。

它使用 JSP 标签在 HTML 网页中插入 Java 代码。标签通常以`<%`开头以`%>`结束。

JSP 是一种 Java servlet，主要用于实现 Java web 应用程序的用户界面部分。网页开发者们通过结合 HTML 代码、XHTML 代码、XML 元素以及嵌入 JSP 操作和命令来编写 JSP。

JSP 通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。

JSP 标签有多种功能，比如访问数据库、记录用户选择信息、访问 JavaBeans 组件等，还可以在不同的网页中传递控制信息和共享信息。





## 二、为什么要用Jsp？

JSP 也是一种 Servlet，因此 JSP 能够完成 Servlet 能完成的任何工作。

JSP 程序与 CGI 程序有着相似的功能，但和 CGI 程序相比，JSP 程序有如下优势：

- 性能更加优越，因为 JSP 可以直接在 HTML 网页中动态嵌入元素而不需要单独引用 CGI 文件。
- 服务器调用的是已经编译好的 JSP 文件，而不像 CGI/Perl 那样必须先载入解释器和目标脚本。
- JSP 基于 Java Servlets API，因此，JSP 拥有各种强大的企业级 Java API，包括 JDBC，JNDI，EJB，JAXP 等等。
- JSP 页面可以与处理业务逻辑的 servlets 一起使用，这种模式被 Java servlet 模板引擎所支持。

最后，JSP 是 Java EE 不可或缺的一部分，是一个完整的企业级应用平台。这意味着 JSP 可以用最简单的方式来实现最复杂的应用。



### 2.1  JSP 的优势

- 与 ASP 相比：JSP 有两大优势。首先，动态部分用 Java 编写，而不是 VB 或其他 MS 专用语言，所以更加强大与易用。第二点就是 JSP 易于移植到非 MS 平台上。
- 与纯 Servlets 相比：JSP 可以很方便的编写或者修改 HTML 网页而不用去面对大量的 println 语句。
- 与 SSI 相比：SSI 无法使用表单数据、无法进行数据库链接。
- 与 JavaScript 相比：虽然 JavaScript 可以在客户端动态生成 HTML，但是很难与服务器交互，因此不能提供复杂的服务，比如访问数据库和图像处理等等。
- 与静态 HTML 相比：静态 HTML 不包含动态信息。



## 三、Jsp语法组成







## 四、JSP 隐式对象或内置对象

JSP 隐式对象是 JSP 容器为每个页面提供的 Java 对象，开发者可以直接使用它们而不用显式声明。JSP 隐式对象也被称为预定义变量。

JSP 所支持的九大隐式对象：

| **对象**      | **描述**                                                     |
| ------------- | ------------------------------------------------------------ |
| `request`     | **HttpServletRequest**类的实例                               |
| `response`    | **HttpServletResponse**类的实例                              |
| `out`         | **PrintWriter**类的实例，用于把结果输出至网页上              |
| `session`     | **HttpSession**类的实例                                      |
| `application` | **ServletContext**类的实例，与应用上下文有关                 |
| `config`      | **ServletConfig**类的实例                                    |
| `pageContext` | **PageContext**类的实例，提供对 JSP 页面所有对象以及命名空间的访问 |
| `page`        | 类似于 Java 类中的 this 关键字                               |
| `Exception`   | **Exception**类的对象，代表发生错误的 JSP 页面中对应的异常对象 |

### 6.1. <font color = "red"> request 对象</font>

`request`对象是`javax.servlet.http.HttpServletRequest` 类的实例。

每当客户端请求一个 JSP 页面时，JSP 引擎就会制造一个新的`request`对象来代表这个请求。

`request`对象提供了一系列方法来获取 HTTP 头信息，cookies，HTTP 方法等等。

```jsp
<%
    //数据存于request中
    request.setAttribute("name", "张欣");
%>
```

```jsp
<!--// request 获取数据   getAttribute -->
<%=request.getAttribute("name")%>

```



### 6.2. response 对象

`response`对象是`javax.servlet.http.HttpServletResponse`类的实例。

当服务器创建`request`对象时会同时创建用于响应这个客户端的`response`对象。

`response`对象也定义了处理 HTTP 头模块的接口。通过这个对象，开发者们可以添加新的 cookies，时间戳，HTTP 状态码等等。

```jsp
```



### 6.3. out 对象

`out`对象是`javax.servlet.jsp.JspWriter`类的实例，用来在`response`对象中写入内容。

最初的`JspWriter`类对象根据页面是否有缓存来进行不同的实例化操作。可以在`page`指令中使用`buffered='false'`属性来轻松关闭缓存。

`JspWriter`类包含了大部分`java.io.PrintWriter`类中的方法。不过，`JspWriter`新增了一些专为处理缓存而设计的方法。还有就是，`JspWriter`类会抛出`IOExceptions`异常，而`PrintWriter`不会。

下表列出了我们将会用来输出`boolean`，`char`，`int`，`double`，`String`，`object`等类型数据的重要方法：

| **方法**                     | **描述**                   |
| ---------------------------- | -------------------------- |
| **out.print(dataType dt)**   | 输出 Type 类型的值         |
| **out.println(dataType dt)** | 输出 Type 类型的值然后换行 |
| **out.flush()**              | 刷新输出流                 |

```jsp
```

#### 1. out对象应用场景

如：打印`<script>代码</script>>`

切记这个对象用完要记得关闭



### 6.4. <font color = "red"> session 对象</font>

`session`对象是`javax.servlet.http.HttpSession`类的实例。和 Java Servlets 中的`session`对象有一样的行为。

`session`对象用来跟踪在各个客户端请求间的会话。

#### 1. <font color = "red"> Session：会话</font>

当我们打开浏览器来访问一个网站，一个会话就开始了;只要浏览器没有关闭，会话就一直存在;当浏览器关闭，会话结束；只要浏览器没有关闭，则在网站的任何页面（jsp, servlet） 都可以获取session中的值；当用户第一次访url地址的时候，就会自动生成一个jsessionId存放在本地的cookie中;

```jsp
session.setAttribute("username","admin");
// 返回值为Object
Object obj = session.getAttribute("username")
```

```jsp
<%
	//数据存于session中
    session.setAttribute("nickname", "陈总");
%>
```

```jsp
<!--// session 获取数据   getAttribute -->
<%=session.getAttribute("nickname")%>
```

#### 2. <font color = "red">Session 超时:</font>

Session超时理解为：浏览器和服务器之间创建了一个Session，由于客户端长时间（休眠时间）没有与服务器交互，服务器将此Session销毁，客户端再一次与服务器交互时之前的Session就不存在了。

设置Session超时时间方式：

方式一： 即客户端连续两次与服务器交互间隔时间最长为2分钟，2分钟后session.getAttribute()获取的值为空

```xml
在web.xml中设置session-config如下：
 <session-config>
  <session-timeout>2</session-timeout>
 </session-config>
```

```jsp
session.getCreationTime()   获取session的创建时间
session.getLastAccessedTime()  获取上次与服务器交互时间
session.getMaxInactiveInterval() 获取session最大的不活动的间隔时间，以秒为单位120秒。
```

方式二：在Tomcat的/conf/web.xml中session-config,默认值为：30分钟

```xml
 <session-config>
        <session-timeout>30</session-timeout>
    </session-config>
```

方式三： 在Servlet中设置

```java
HttpSession session = request.getSession();
  session.setMaxInactiveInterval(60);//单位为秒
```

#### 4. 说明：

1. 优先级：Servlet中API设置 > 程序/web.xml设置 > Tomcat/conf/web.xml设置
2. 若访问服务器session超时（本次访问与上次访问时间间隔大于session最大的不活动的间隔时间）了，即上次会话结束，但服务器与客户端会产生一个新的会话，之前的session里的属性值全部丢失，产生新的sesssionId
3. 客户端与服务器一次有效会话（session没有超时），每次访问sessionId相同，若代码中设置了session.setMaxInactiveInterval()值，那么这个session的最大不活动间隔时间将被修改，并被应用为新值。
4. Session的销毁（代表会话周期的结束）：在某个请求周期内调用了Session.invalidate()方法，此请求周期结束后，session被销毁；或者是session超时后自动销毁；或者客户端关掉浏览器
5. 对于JSP，如果指定了<%@ page session="false"%>，则在JSP中无法直接访问内置的session变量，同时也不会主动创建session，因为此时JSP未自动执行request.getSession()操作获取session。

#### 5.<font color = "red"> session应用场景(访问控制):</font>

* 下载文件，判断用户是否登录，如果有登录过，则可以下载否则提示登录
* 只有登录的用户才能进入网站的后台

操作步骤：

* 用户登录成功，我们将用户登录的信息存储在session中[会话]

```java
Session对象.setAttribute(“key”,value)
```

* 需要验证用户权限的页面或者servlet中通过对session中的值进行判断来决定是放行还是跳转到登录界面

```java
If(session对象.getAttribute(“key”)==null)
{
    //跳转到登录界面
}
```



### 6.5. <font color = "red"> application 对象</font>

`application`对象直接包装了 servlet 的`ServletContext`类的对象，是`javax.servlet.ServletContext`类的实例。

这个对象在 JSP 页面的整个生命周期中都代表着这个 JSP 页面。这个对象在 JSP 页面初始化时被创建，随着`jspDestroy()`方法的调用而被移除。

通过向`application`中添加属性，则所有组成 web 应用的 JSP 文件都能访问到这些属性。

使用`setAttribute`设置了属性之后,在当前的整个应用程序中都可以使用;

```jsp
<%
    //数据存于application中
    application.setAttribute("money", "10爽");
%>
```

```jsp
<!--// application 获取数据   getAttribute -->
<%=application.getAttribute("money")%>
```

#### 1. `Applicatiion`应用场景：

如：可以简单记录访问网站的在线人数.



### 6.6. config 对象

`config`对象是`javax.servlet.ServletConfig`类的实例，直接包装了 servlet 的`ServletConfig`类的对象。

这个对象允许开发者访问 `Servlet` 或者 `JSP` 引擎的初始化参数，比如文件路径等。

以下是 `config `对象的使用方法，不是很重要，所以不常用：

```text
config.getServletName();
```

它返回包含在`<servlet-name>`元素中的 servlet 名字，注意，`<servlet-name>`元素在`WEB-INF\web.xml`文件中定义。





### 6.7. <font color = "red"> pageContext 对象</font>

`pageContext`对象是`javax.servlet.jsp.PageContext`类的实例，用来代表整个 JSP 页面。

这个对象主要用来访问页面信息，同时过滤掉大部分实现细节。

这个对象存储了`request`对象和`response`对象的引用。`application`对象，`config`对象，`session`对象，`out`对象可以通过访问这个对象的属性来导出。

`pageContext`对象也包含了传给 JSP 页面的指令信息，包括缓存信息，ErrorPage URL,页面 scope 等。

`PageContext`类定义了一些字段，包括 `PAGE_SCOPE`，`REQUEST_SCOPE`，`SESSION_SCOPE`， `APPLICATION_SCOPE`。它也提供了 40 余种方法，有一半继承自`javax.servlet.jsp.JspContext` 类。

其中一个重要的方法就是`removeArribute()`，它可接受一个或两个参数。比如，`pageContext.removeArribute("attrName")`移除四个 `scope` 中相关属性，但是下面这种方法只移除特定` scope` 中的相关属性：

```text
pageContext.removeAttribute("attrName", PAGE_SCOPE);
```



`pageContext.setAttribute("key","value")`与`pageContext.getAttribute("key","value")`主要作用是获取其他对象：

```jsp
pageContext.setAttribute("key","value") // 在页面上定义一个专门存储数据的对象，
pageContext.getAttribute("key","value") // 取数据
```

如：

```jsp
<%
    //数据存放于setAttribute中
    pageContext.setAttribute("username", "罗水文");
%>
```

```jsp
<!--//pageContext 获取数据   getAttribute -->
<%=pageContext.getAttribute("username")%>
```



### 6.8. page 对象

这个对象就是页面实例的引用。它可以被看做是整个 JSP 页面的代表。

`page`对象就是`this`对象的同义词。



### 6.9. exception 对象

`exception`对象包装了从先前页面中抛出的异常信息。它通常被用来产生对出错条件的适当响应。





## 五、页面跳转

### 5.1 通过Request跳转

* 转发：`request.getRequestDispatcher("index.jsp").forward(request, response);`request转发:只能在当前网址内部（），效率比较高。

```jsp
<%--request转发:只能在当前网址内部（）--%>
<%
    request.setAttribute("username", "tom");
    request.setAttribute("password", "123456");
    request.getRequestDispatcher("page_2.jsp").forward(request, response);
%>
```

```jsp
<%--request转发--%>
<%=request.getAttribute("username")%>
<%=request.getAttribute("password")%>
```



### 5.2 通过Response跳转

* 重定向：`response.sendRedirect("page_2.jsp");`在当前网址内部，也可以是外部的url地址

```jsp
<%--response重定向：在当前网址内部，也可以是外部的url地址--%>
<%
    response.sendRedirect("page_2.jsp");
%>
```



### 5.3 转发和重定向

1. 转发`(request.getRequestDispatcher(“index.jsp”).forward(request,response)) ;`操作的时候浏览器地址栏还停留在原来的url地址，而页面内容已经显示的是`index.jsp`的内容;而重定向`(response.sendRedirect(“index.jsp”)) ;`此时浏览器地址栏和显示的内容页是一致，都是`index.jsp.`
2.  转发的时候可以携带数据`(request.setAttribute(“key”,value));`之后可以在新的页面获取`(request.getAttribute(“key”)),`可以多次转发 ;而重定向不能使用`setAttribute()/getAttribute()`的操作来设置或者获取数据. 传递数据只能通过url直接传递;
3. 二者的原理不同: 转发是服务器内部的行为,对于请求者来说，根本不关注内部的行为只关注自己发送请求的响应; 重定向其实是浏览器重新发送的请求,多次请求者和服务器进行交互的操作.
4. 相对来讲，因为是服务器内部行为,内部转发，所以效率会高一些.
5. 转发是服务器**内部**的行为，所以转发页面也是同一个网站的不同部分;但是不能跳转到外部网站;而重定向可以是内部或者外部的网站`url`.
6. 使用场合:如果需要携带数据(很多 对象)到下一个请求地址，则可以使用转发，否则可以使用重定向.



### 5.3 通过超链接按钮JS Url跳转

```jsp
location.href = "news?op=delete&nid=" + $(this).val();
```

