---
title: Spring
date: 2021-08-22 21:47:03
permalink: /pages/66bf75/
categories:
  - 《Spring》学习笔记
tags:
  - 
---
# 一、Spring

​		Spring诞生之初，主要目的是用来替代更加重量级的企业级技术 尤其是EJB，相对于EJB来说Spring提供了更加轻量级和简单的编程模型。它增强了简单老式的Java对象POJO的功能，使其具备了之前只有EJB和其他企业级Java规范才有的功能。

## 1、Spring的优点

* Spring是一个开源的免费的框架（容器）
* Spring是一个轻量级、非入侵式的框架
* 控制反转（IOC）、面向切面（AOP）
* 支持事务处理、对框架整合的支持！

总结：Spring就是一个轻量级的控制反转（IOC）和面向切面（AOP）的框架！

非常轻量级的容器，低侵入，代码污染低。独立于各种应用服务器.DI(IOC)降低了业务对象替换复杂性



## 2、核心思想

Spring 最核心的两个技术思想是：IoC 和 Aop

### 

## 3、Spring组成

![](https://singerwimg-1300001977.cos.accelerate.myqcloud.com/2021/08/15/08dec90767467.jpg)

1. `Core模块`：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。
2. `Beans模块`：**提供了框架的基础部分，包括反转控制和依赖注入。其中**Bean Factory**是容器核心（工厂），本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全**由容器控制**，而且**提倡面向接口编程**，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由**BeanFactory**来维护。**
3. `Context模块`：**以Core和Beans为基础，集成Beans模块功能并添加**资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件**传播等；核心接口是ApplicationContext。**
4. `EL模块`：**提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。**
5. `AOP模块`：**Spring AOP模块提供了符合 *AOP Alliance*规范的面向方(切)面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。**
6. `DataACCESS模块`：Spring本身的 JDBC, 和其他的框架整合 ORM（Mybatis Hibernate）
7. `WEB模块`: Web的部分（Spring MVC）,和其他框架如:Struts2整合的部分;



## 4、Spring体系结构

Spring 当前框架有**20**个 jar 包，大致可以分为**6**大模块:

- 1. 为什么使用 Spring

- 2. 核心思想

  - 2.1. IoC
  - 2.2. Aop

- 3. Spring 体系结构

  - 3.1. Core Container
    - 3.1.1. BeanFactory
    - 3.1.2. ApplicationContext
  - 3.2. AOP and Instrumentation
  - 3.3. Messaging
  - 3.4. Data Access / Integaration
  - 3.5. Web
  - 3.6. Test

- 4. 术语

<img src="https://singerwimg-1300001977.cos.accelerate.myqcloud.com/2021/08/18/690141a923c94.png" style="zoom:200%;" />

Spring 当前框架有**20**个 jar 包，大致可以分为**6**大模块:

- 1. 为什么使用 Spring

- 1. 核心思想

  - 2.1. IoC
  - 2.2. Aop

- 1. Spring 体系结构

  - 3.1. Core Container
    - 3.1.1. BeanFactory
    - 3.1.2. ApplicationContext
  - 3.2. AOP and Instrumentation
  - 3.3. Messaging
  - 3.4. Data Access / Integaration
  - 3.5. Web
  - 3.6. Test

- 1. 术语

 ## 5、Spring能做什么？

Spring能程序员简化开发：

1. Spring根据配置文件来进行创建及组装**对象间依赖关系(IOC)**，只需要改配置文件即可，无需重新编译。Spring能帮我们根据配置文件创建及组装对象之间的依赖关系。
2. 重复业务逻辑的处理，在**AOP思想**中，Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制等。
3. 原始的支持jdbc事务处理繁琐，Spring能非常简单的帮我们**管理数据库事务**。
4. Spring还提供了与第三方**ORM框架无缝集成**，而且自己也提供了一套JDBC访问模板，来方便数据库访问。
5. Spring还提供与第三方**Web（如Strut**s、JSF）框架无缝集成，而且自己也提供了一套**Spring MVC**框架，来方便web层搭建。
6. Spring能方便的与**Java EE（如Java Mail、任务调度）整合**，与更多技术整合（比如缓存框架）。



## 6、拓展

* Spring Boot 
  * 一个快速开发的脚手架
  * 可以快速开发单个微服务。
  * 和Maven一样、是约定大于配置。
* Spring Cloud 
  * 基于SpringBoot实现的。

现在大部分公司都在使用Spring Boot进行快速开发，**学习SpringBoot的前台，是需要完全掌握Spring及Spring MVC，是承上启下的作用！**

Spring弊端：发展的太久了，违背的原来的理念，配置太繁琐了，简称：配置地狱！



# 二、IOC理论推导

1. UserDao接口
2. UserDaoImpl实现类
3. UserService业务接口
4. UserServiceImpl业务实现类



在我们之前的业务中，用户的需求可能会影响到我们原来的代码，我们需要根据用户的需求去改写代码，修改代码量十分多，修改一次的成本与代价十分昂贵！

我们使用一个Set接口实现，就会发生革命性的变化！

```java
package com.singerw.dao.impl;

import com.singerw.dao.UserDao;

public class UserDaoImpl implements UserDao {
    private UserDao userDao;
    //利用Set进行动态实现值得注入！
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}
```

* 之前，程序是主动创建对象！控制器在程序员受伤！
* 使用了Set注入后，程序不再具有主动权，而是变成了被动的接受对象！

这种思想，从本质上解决了问题，我们程序员不用再用管理对象的创建了，系统的耦合性大大的降低，可以更加专注在业务的实现上！这就是IOC的原型！



# 三、Spring Bean

## 1、 定义

如何注册一个 Spring Bean？

通过 BeanDefinition 和外部单体对象来注册



## 2、什么是 BeanDefinition

`BeanDefinition` 是 Spring Framework 中定义 Bean 的配置元信息接口，包含：

- Bean 类名
- Bean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等
- 其他 Bean 引用
- 配置设置，如 Bean 属性（Properties）



## 3、Spring Bean 命名规则

​		每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。

在基于 XML 的配置元信息中，开发人员可用 id 或者 name 属性来规定 Bean 的标识符。通常 Bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。

Bean 的 id 或 name 属性并非必须制定，如果留空的话，容器会为 Bean 自动生成一个唯一的名称。Bean 的命名尽管没有限制，不过官方建议采用驼峰的方式，更符合 Java 的命名约定。

**Spring Bean 命名生成器**

Spring 提供了两种 Spring Bean 命名生成器：

- DefaultBeanNameGenerator：默认通用 BeanNameGenerator 实现。
- AnnotationBeanNameGenerator：基于注解扫描的 BeanNameGenerator 实现。

## 4、注册 Spring Bean

### 3.1 XML 配置元信息





### 3.2 注解配置元信息

使用 `@Bean`、`@Component`、`@Import` 注解注册 Spring Bean。

这个import，一般用户团队开发使用，他可以将多个配置文件，导入合并为一个

假设，现在项目中有多个人同时开发，这桑耳复制不用的类开发，不同的类需要注册不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！

* 张三 zhangsan.xml
* 李四 lisi.xml
* 王五 wangwu.xml
* applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  
    <import resource="zhangsan.xml"></import>
    
    <import resource="lisi.xml"></import>
    
    <import resource="wangwu.xml"></import>
    
</beans>
```

使用的时候，使用总的配置文件xml就可以了，会自动合并xml和xml中重名的配置。





### 3.3 Java API 配置元信息

- 命名方式：`BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)`
- 非命名方式：`BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,Be` `anDefinitionRegistry)`
- 配置类方式：`AnnotatedBeanDefinitionReader#register(Class...)`



# 四、IOC — 控制反转

控制反转（IOC），不是什么技术，而是一种设计思想，其作用是实例化具体的bean,动态装配bean。

* 类的一些属性: (例如UserService中的userDao成员属性)是由当前类(UserService)自己控制其实例化，现在不是由当前类(UserService)自己控制。现在Spring是利用**接口来**控制的。由原来控制实现转为spring现在来控制接口(向上反转).
* 我们可以使用xml或者注解来进行相关配置，spring会根据配置和约定，对独享进行实例化和属性装配。

**好处：是spring 的核心机制，可以使Spring的bean以配置文件组织在一起，而不是硬编码方式耦合，耦合性相对来降低了；另外，注入是使用配置文件来实现，这样修改来非常的方便。**



## 1、Spring IOC容器解析

​			`Spring Ioc`容器的代表就是`org.springframework.beans`包中的**`BeanFactory`**接口，`BeanFactory`接口提供了`IoC`容器最基本功能；而`org.springframework.context`包下的`ApplicationContext`接口扩展**了**`BeanFactory`**，还提供了与`Spring AOP`集成、国际化处理、事件传播及提供不同层次的`context`实现 (如针对`web`应用的`WebApplicationContext`)。简单说， `BeanFactory`提供了`IoC`容器最基本功能，而 `ApplicationContext` 则增加了更多支持企业级功能支持**。`ApplicationContext`完全继承`BeanFactory`，因而`BeanFactory`所具有的语义也适用于`ApplicationContext`。



## 2、HelloSpring

```java
package com.singerw.pojo;

public class Hello {
    private String str;

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        this.str = str;
    }


    public Hello(String str) {
        this.str = str;
    }

    public Hello() {
    }

    @Override
    public String toString() {
        return "Hello{" +
                "str='" + str + '\'' +
                '}';
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--    使用Spring创建我们的对象
    Hello hello = new Hello();
    bean = 对象  new Hello();
    id = 变量名
    class = new 的对象
    property 相当于给对象中的属性设值。
    -->
    <bean id="hello" class="com.singerw.pojo.Hello">
        <property name="str" value="Spring"/>
    </bean>
</beans>
```

```java
import com.singerw.pojo.Hello;
import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {

    @Test
    public void Test() {
        // 获取Spring上下文的对象！
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
        //对象现在都在Spring中管理了，我们要使用，就直接去里面取出来就行了。
        Hello hello = (Hello) applicationContext.getBean("hello");
        System.out.println(hello.toString());
    }
}
```

> Hello{str='Spring'}

* Hello对象是谁创建的？

hello对象是由Spring创建的

* hello对象的属性是怎么设置的？

hello对象的属性使用Spring容器设置的

**这个过程就叫做控制反转：**

控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring之后，对象是由Spring创建的

反转：程序本身不创建对象，而变成被动的接受对象。

依赖注入：就是利用set方法来进行注入的

IOC是一种编程思想，由主动的编程变成被动的接收。

**不用再程序中去改动了，想要实现不同的操作，只需要再XML配置文件中进行修改，所谓的IOC，一句话搞懂就是：对象由Spring来创建，管理和装配！**





## 2、获取Bean





## 3、Bean的标识以及说明









# 五、Spring5 - Annotation

要使用注解须知：

* 导入约束：`xmlns:context="http://www.springframework.org/schema/context"`

* 配置注解的支持：`<context:annotation-config></context:annotation-config>`

## 1.注解实现Bean依赖注入 ，自动装配

* @Autowired 
  * 直接在属性上
  * 也可以在Set方式上使用。
  * 使用@Autowired 我们可以不用编写Set方法了，前提是这个自动装配的属性在IOC容器中存在，且符合名字ByName

> 如果显示的定义了@Autowired （required = false）说明这个对象可以为null，否则不容许为空！

```java
public class UsersEntity {
    @Autowired(required = false)
    private String username;
}
```

> 如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired 】完成的时候，我们可以使用@Qualifier(value = "zx")去配合@Autowired的使用，指定一个唯一的bean对象注入！

```java
public class UsersEntity {
@Qualifier(value = "zx")
private String username;
}
```



* @Resource注解

```java
public class UsersEntity {
@Resource(value = "zx")
private String username;
}
```



## 2、@Autowired和@Resource的区别

- 都是用来自动装配的，都可以放在属性的字段上。
- @Autowired 都过ByType的方式实现，而且必须要去这个对象存在，不然就会空指针异常！【常用的】
- @Resource默认通过ByName的方式实现，如果找不到名字，则通过byType实现，如果两个都找不到的情况下，就会报错



## 3、使用注解开发

在Spring4后，要使用注解开发，必须要保证让注解生效，就需要开启注解的支持！

```xml
<!--注解的支持-->
<context:annotation-config></context:annotation-config>
```

在Spring4后，要使用注解开发，必须要保证导入spring-aop的jar包

```xml
<!--指定要扫描的包，这个包下的注解就会生效-->
<context:component-scan base-package="com.singerw"></context:component-scan>
```



### 3.1 `@Autowired`

自动装配通过类型，名字。

如果@Autowired 自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired 】完成的时候，我们可以使用@Qualifier(value = "zx")去配合@Autowired的使用，指定一个唯一的bean对象注入！



### 3.2 `@Resource`

自动装配通过名字。类型



### 3.3` @Nullable`

字段标记了这个注解，说明这个字段可以为null





### 3.4  `@Component`

组件。放在类上，说明这个类被Spring管理了。就是bean注入！

相当于`<bean id="address" class="com.singew.pojo.Address"></bean>`





### 3.5 `@Value(value = "XXX")`

给值注解，相当于`<property name="name" value="张欣"></property>`

也可以放在set方法上





### 3.6 @Component的衍生注解

* #### `@Component`

* #### `@Repository(value = "usersDao")`

* #### `@Service(value = "usersService")`

* #### `@RestController`

这四个注解的功能都是一样的。都是代表将类注册到Spring容器中，装配Bean





### 3.7 `Scope(" singleton")`

关于作用域的注解，可以设置`Scope(" singleton")`单例模式和`Scope(" prototype")`原型模式





## 4、 小结

### 4.1 XML和注解的区别：

* XML更加万能，适合于任何场合，维护简单！
* 注解不是自己类使用不了，维护复杂



### 4.1 XML和注解的最佳实践：

一般来说，XML和注解的最佳实践，就是用XML来管理bean，用注解来完成属性的注入！



#  六、Spring 提供了哪些IOC容器配置方式？

### 1、基于 `applicationContext.xml `实现配置

bean 所需的依赖项和服务在XML` 格式的配置文件中指定。这些配置文件通常包含许多`bean` 定义和特定于应用程序的配置选项。它们通常以 `bean` 标签开头。

【例如】：

```xml
<bean id="address" class="com.singew.pojo.Address"></bean>
<bean id="student" class="com.singew.pojo.Student">
    <!--第一种，普通值的注入，value-->
    <property name="name" value="张欣"></property>

    <!--第二种，Bean注入，ref-->
    <property name="address" ref="address"/>

    <!--第三种，数组的注入-->
    <property name="books">
        <array>
            <value>红楼梦</value>
            <value>西游记</value>
            <value>三国演义</value>
            <value>水浒传</value>
        </array>
    </property>

    <!--第四种，List注入-->
    <property name="hobbys">
        <list>
            <value>听歌</value>
            <value>掉代码</value>
            <value>看电影</value>
        </list>
    </property>

    <!--第五种，Map注入-->
    <property name="card">
        <map>
            <entry key="key" value="value"/>
            <entry key="身份证" value="5464556454645651415"/>
            <entry key="银行卡" value="8795461525678954645459845415"/>
        </map>
    </property>

    <!--第六种，Set注入-->
    <property name="games">
        <set>
            <value>LOL英雄联盟</value>
        </set>
    </property>

    <!--第七种，props空值注入-->
    <property name="wife" value=""/>
    
    <property name="info">
        <props>
            <prop key="学号">20171649</prop>
            <prop key="性别">男</prop>
            <prop key="姓名">小明</prop>
        </props>
    </property>
</bean>
```

### 2、基于注解实现配置

可以通过在相关的类，方法或字段声明上使用注解，将 `bean` 配置为组件类本身，而不是使用` XML` 来描述 `bean` 装配。默认情况下，`Spring `容器中未打开注解装配。因此，需要在使用它之前在` Spring `配置文件中启用它。

【例如】：

```xml
<!--注解的支持-->
<context:annotation-config></context:annotation-config>
```

```java
@Repository
public class BlogDaoImpl implements BlogDao {

    @Override
    public PageData getBlogList(int page, int pageSize) {
        String sql = "SELECT g_article.* FROM g_article WHERE acticle_status = 1";
        return DBUtil.exQueryByPage(sql, BlogEntity.class, page, pageSize);
    }
}
```

### 3、基于`Java API/JavaConfig`实现配置

> 完全使用`Java`的方式配置`Spring`，年轻人喜欢这么玩，上了年龄的程序员不想瞎搞。但以后看到Spring开源项目，这么没有`bean`，怎么没有`xml`？别说这不是`Spring`的，丢人了。

`Spring` 的 `Java` 配置是通过使用 `@Bean` 和 `@Configuration` 来实现。

1. `@Bean` 注解扮演与` <bean />` 元素相同的角色。
2. `@Configuration` 类允许通过简单地调用同一个类中的其他 `@Bean` 方法来定义 `bean` 间依赖关系。

【例如】：

**UserEntity：**

```java
@Component
public class UserEntity {
    private String name;

    public String getName() {
        return name;
    }

    @Value("张欣")
    public void setName(String name) {
        this.name = name;
    }

    public UserEntity() {
    }

    public UserEntity(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "UserEntity{" +
            "name='" + name + '\'' +
            '}';
    }
}
```

**SingerwConfig：**

```java
@Configuration
public class SingerwConfig {

    @Bean
    public UserEntity getUser(){
        return new UserEntity();
    }
}
```

**TestUser：**

```java
public class TestUser {
    @Test
    public void getUserTest() {
        ApplicationContext context = new AnnotationConfigApplicationContext(SingerwConfig.class);
        UserEntity getUser = context.getBean("getUser", UserEntity.class);
        System.out.println(getUser.getName());
    }
}
```





# 七、AOP - 面向方面的程序设计框架

Aspect Oriented Programming(面向切面编程或面向方面编程)

* `AOP`：`Aspect Oriented Programming`(面向切面编程或面向方面编程),是一种编程范式，提供从另一个角度来考虑程序结构从而完善面向对象编程(OOP)。
* `AOP`为开发者提供一种进行横切关注点（比如日志关注点横切了支付关注点）分离并织入的机制，把横切关注点分离，然后通过某种技术织入到系统中，从而无耦合的完成了我们的功能。
* 面向切面的编程和面向对象并不矛盾，是对面向对象的思维方式的有效补充。主要将程序中涉及公共问题集中解决，可以解决面向对象和过程化方法中不能很好解决的横切问题如：**事务**，安全，日志，异常处理等横切关注。

## 1、AOP概念

### 1.1 方面/切面（Aspect）

​		方面/切面（Aspect）是切面的**具体实现**,在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段。以目标方法为参照点，根据放置的地方不同，可分为**前置通知**（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、**最终通知**（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。**做什么**?





### 1.2 连接点（Joinpoint）

​		连接点（Joinpoint）表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等. 在**哪里**(很多可以连接的部分)做什么？





### 1.3 切入点（Pointcut）

​		选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法，在AOP中表示为“在**哪里（确定下来）**做的**集合**”.



### 1.4 目标对象（Target Object）

​		需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象.**对谁做这件事**？



### 1.5 代理对象（AOP Proxy Object）

​		AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用**JDK动态代理【返回接口实例】**或**CGLIB[可以是类实例]**代理实现，而通过拦截器模型应用切面。



### 1.6 织入（Weaving）

​		将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在**编译期、类装载期及运行**期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。



### 1.7 通知类型

* 前置通知（Before Advice）:在切入点选择的连接点处的方法**之前**执行的通知，该通知不影响正常程序执行流程（除非该通知抛出异常，该异常将中断当前方法链的执行而返回）。
* 后置通知（After Advice）: 在切入点选择的连接点处的方法**之后**执行的通知，包括如下类型的后置通知：
* 后置返回通知（After returning Advice）:在切入点选择的连接点处的方法正常执行完毕时执行的通知，必须是连接点处的方法没抛出任何异常正常返回时才调用后置通知。
* 后置异常通知（After throwing Advice）: 在切入点选择的连接点处的方法抛出异常返回时执行的通知，必须是连接点处的方法抛出任何异常返回时才调用异常通知。
* 后置最终通知（After finally Advice）: 在切入点选择的连接点处的方法返回时执行的通知，不管抛没抛出异常都执行，类似于Java中的finally块。
* 环绕通知（Around Advices）：环绕着在切入点选择的连接点处的方法所执行的通知，环绕通知可以在方法调用之前和之后自定义任何行为，并且可以决定是否执行连接点处的方法、替换返回值、抛出异常等.



## 2、基于XML的Spring AOP配置





## 3、代理模式—静态代理

代理模式是SpringAOP的底层！【SpringAOP和SpringMVC面试必问】

**优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。** 
**缺点：**

* **代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。**
* **如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。**







## 4、代理模式—动态代理

代理模式是SpringAOP的底层！【SpringAOP和SpringMVC面试必问】







